#+TITLE: Securing your GraphQL API with Hasura
#+SUBTITLE: [[https://hasura.io/events/hasura-con-2022/][HasuraCon 2022]]
#+AUTHOR: David A. Ventimiglia
#+EMAIL: davidaventimiglia@hasura.io

#+options: timestamp:nil title:t toc:nil todo:t |:t num:nil author:nil

#+REVEAL_DEFAULT_SLIDE_BACKGROUND: ./assets/slide_background.png
#+REVEAL_INIT_OPTIONS: transition:'none', controlsLayout:'edges', progress:false, controlsTutorial:false
#+REVEAL_THEME: black
#+REVEAL_TITLE_SLIDE_BACKGROUND: ./assets/slide_background.png
#+REVEAL_PLUGINS: (highlight)

* 
#+CAPTION: https://tinyurl.com/43vxsdmj
#+ATTR_HTML: :width 50%
#+ATTR_HTML: :height 50%
[[file:assets/qr.png]]

* Introduction

*** Program

- [[https://hasura.io/docs/latest/graphql/core/auth/index/][+Hasura Authentication+]]
- [[https://hasura.io/docs/latest/graphql/cloud/security/api-limits/][Hasura API Limits]]
- [[https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules/][Hasura Authorization]]
- [[https://hasura.io/docs/latest/graphql/cloud/security/allow-lists/][Hasura Allow Lists]]
- [[https://hasura.io/docs/latest/graphql/core/api-reference/restified/][Hasura REST Endpoints]]

#+begin_NOTES
Note that we don't illustrate authentication in this talk, though we
will touch on it briefly.
#+end_NOTES

*** Principles

- Risk Management :: /Life is about trade-offs./
- Goal Setting :: /Confidentiality, Integrity, Availability/
- Defense in Depth :: /Bottom-Up/
- Simplicity :: /Complexity is the Enemy of Security/
- Least Privilege :: /The most secure API does nothing at all./

*** Threats

#+REVEAL_HTML: <div class="column" style="float:left; width:75%">

- Deep Queries :: /Confidentiality, Availability/
- Recursive Queries :: /Availability/
- Unbounded Queries :: /Confidentiality, Availability/
- Malicious Queries :: /Confidentiality/
- Batch Requests :: /Confidentiality, Availability/

#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width:25%;">

[[file:assets/GraphQL Logo (Rhodamine).svg]]

#+REVEAL_HTML: </div>

*** Deep Queries / Recursive Queries

#+begin_src graphql
  query {
    author(id: 42) {
      posts {
        author {...and so on...
        }
      }
    }
  }
#+end_src

*** Unbounded / Large Queries

#+begin_src graphql
  query {
    authors(first: 1000) {
      name
      posts(last: 100) {
        title
        content
      }
    }
  }
#+end_src

*** Malicious Queries

#+begin_src graphql
  query User {
    user (id: "User*") {
      email
      id 
    }
  }
#+end_src

*** Batch Requests

#+begin_src graphql
  query MaliciousQuery {
    alias1: fieldName { subField1 subField2 ...}
    alias2: fieldName { subField1 subField2 ...}
    ...
    alias10: fieldName { subField1 subField2 ...}
    ...
    alias100: fieldName { subField1 subField2 ...
    ...
    alias1000: fieldName { subField1 subField2 ...}
    ...
  }
#+end_src

* Workshop

*** Log into Heroku

#+ATTR_HTML: :width 40%
#+ATTR_HTML: :height 40%
[[file:assets/log_into_heroku.png]]

*** Log into Hasura Cloud

#+ATTR_HTML: :width 40%
#+ATTR_HTML: :height 40%
[[file:assets/log_into_hasura_cloud.png]]

*** Create a new Hasura Cloud Project

#+ATTR_HTML: :width 40%
#+ATTR_HTML: :height 40%
[[file:assets/create_new_hasura_project.png]]

*** Create a new Heroku database

*** +Connect to the database+

#+begin_src shell :export both
  psql -h <hostname> -p <port> -d <db> -U <username> psql
  heroku psql -a <app>
#+end_src

*** +Secure the DB+

- Create a dedicated DB user for PROD.
- ~REVOKE~ DML (maybe).
- ~REVOKE~ DDL (definitely).
- Use a [[https://hasura.io/docs/latest/graphql/core/getting-started/docker-simple/][separate dev instance]] with elevated permissions for data modeling.
- Use an env var like ~PG_DATABASE_URL~ with your Hasuras.

#+REVEAL: split

 #+begin_src sql
   -- Read-only? (not on Heroku hobby tier!)
   CREATE USER hasuraprod WITH PASSWORD 'hasuraprod';
   GRANT CONNECT ON DATABASE <db> TO hasuraprod;
   GRANT USAGE ON SCHEMA <schema> TO hasuraprod;
   GRANT SELECT ON ALL TABLES IN SCHEMA <schema> TO hasuraprod;
   GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA <schema> TO hasuraprod;
 #+end_src

*** Secure the Service

- ~HASURA_GRAPHQL_ADMIN_SECRET~

*** +Add Authentication+

- ~HASURA_GRAPHQL_AUTH_HOOK~
- ~HASURA_GRAPHQL_AUTH_HOOK_MODE~

*** +Disable Hasura Console+

- ~HASURA_GRAPHQL_ENABLE_CONSOLE~

*** Disable Schema Introspection

#+ATTR_HTML: :width 80%
#+ATTR_HTML: :height 80%
[[file:assets/disable_schema_introspection.png]]

*** Create the Data Model

#+begin_src sql
-- -*- sql-product: postgres; -*-

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE "public"."account" ("id" uuid NOT NULL DEFAULT gen_random_uuid(), "name" text NOT NULL, "created_at" timestamptz NOT NULL DEFAULT now(), "updated_at" timestamptz NOT NULL DEFAULT now(), PRIMARY KEY ("id") );
CREATE OR REPLACE FUNCTION "public"."set_current_timestamp_updated_at"()
RETURNS TRIGGER AS $$
DECLARE
  _new record;
BEGIN
  _new := NEW;
  _new."updated_at" = NOW();
  RETURN _new;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER "set_public_account_updated_at"
BEFORE UPDATE ON "public"."account"
FOR EACH ROW
EXECUTE PROCEDURE "public"."set_current_timestamp_updated_at"();
COMMENT ON TRIGGER "set_public_account_updated_at" ON "public"."account" 
IS 'trigger to set value of column "updated_at" to current timestamp on row update';

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE "public"."product" ("id" uuid NOT NULL DEFAULT gen_random_uuid(), "created_at" timestamptz NOT NULL DEFAULT now(), "updated_at" timestamptz NOT NULL DEFAULT now(), "name" text NOT NULL, "price" integer NOT NULL, PRIMARY KEY ("id") );
CREATE OR REPLACE FUNCTION "public"."set_current_timestamp_updated_at"()
RETURNS TRIGGER AS $$
DECLARE
  _new record;
BEGIN
  _new := NEW;
  _new."updated_at" = NOW();
  RETURN _new;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER "set_public_product_updated_at"
BEFORE UPDATE ON "public"."product"
FOR EACH ROW
EXECUTE PROCEDURE "public"."set_current_timestamp_updated_at"();
COMMENT ON TRIGGER "set_public_product_updated_at" ON "public"."product" 
IS 'trigger to set value of column "updated_at" to current timestamp on row update';

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE "public"."order" ("id" uuid NOT NULL DEFAULT gen_random_uuid(), "created_at" timestamptz NOT NULL DEFAULT now(), "updated_at" timestamptz NOT NULL DEFAULT now(), "account_id" uuid NOT NULL, PRIMARY KEY ("id") , FOREIGN KEY ("account_id") REFERENCES "public"."account"("id") ON UPDATE restrict ON DELETE restrict);
CREATE OR REPLACE FUNCTION "public"."set_current_timestamp_updated_at"()
RETURNS TRIGGER AS $$
DECLARE
  _new record;
BEGIN
  _new := NEW;
  _new."updated_at" = NOW();
  RETURN _new;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER "set_public_order_updated_at"
BEFORE UPDATE ON "public"."order"
FOR EACH ROW
EXECUTE PROCEDURE "public"."set_current_timestamp_updated_at"();
COMMENT ON TRIGGER "set_public_order_updated_at" ON "public"."order" 
IS 'trigger to set value of column "updated_at" to current timestamp on row update';

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE "public"."order_detail" ("id" uuid NOT NULL DEFAULT gen_random_uuid(), "created_at" timestamptz NOT NULL DEFAULT now(), "updated_at" timestamptz NOT NULL DEFAULT now(), "units" integer NOT NULL, "order_id" uuid NOT NULL, "product_id" uuid NOT NULL, PRIMARY KEY ("id") , FOREIGN KEY ("order_id") REFERENCES "public"."order"("id") ON UPDATE restrict ON DELETE restrict, FOREIGN KEY ("product_id") REFERENCES "public"."product"("id") ON UPDATE restrict ON DELETE restrict);
CREATE OR REPLACE FUNCTION "public"."set_current_timestamp_updated_at"()
RETURNS TRIGGER AS $$
DECLARE
  _new record;
BEGIN
  _new := NEW;
  _new."updated_at" = NOW();
  RETURN _new;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER "set_public_order_detail_updated_at"
BEFORE UPDATE ON "public"."order_detail"
FOR EACH ROW
EXECUTE PROCEDURE "public"."set_current_timestamp_updated_at"();
COMMENT ON TRIGGER "set_public_order_detail_updated_at" ON "public"."order_detail" 
IS 'trigger to set value of column "updated_at" to current timestamp on row update';

create or replace function product_search(search text)
  returns setof product as $$
  select *
  from product
  where
  name ilike ('%' || search || '%')
$$ language sql stable;

create extension if not exists pg_trgm;

create index if not exists product_gin_idx on product
  using gin ((name) gin_trgm_ops);

create or replace function product_fuzzy_search(search text)
  returns setof product as $$
  select *
  from product
  where
  search <% (name)
  order by
  similarity(search, (name)) desc
  limit 5;
$$
language sql stable;

create or replace function product_sku(product_row product)
  returns text as $$
  select md5(product_row.name)
$$
language sql stable;

alter table "public"."product" add constraint "non_negative_price" check (price > 0);

create index if not exists account_name_idx on account (name);

CREATE TYPE status AS ENUM ('new', 'processing', 'fulfilled');

alter table "public"."order" add column "status" status
 null;

create table if not exists region (
  value text primary key,
  description text);

alter table "public"."order" add column "region" Text
 null;

alter table "public"."order"
  add constraint "order_region_fkey"
  foreign key ("region")
  references "public"."region"
  ("value") on update restrict on delete restrict;
#+end_src

*** Set API Limits

#+ATTR_HTML: :width 80%
#+ATTR_HTML: :height 80%
[[file:assets/set_api_limits.png]]

*** Apply Permissions

*** Use Allow Lists

*** Create REST Endpoints

* Discussion

*** GraphQL Security Orthodoxy

AKA: rituals, cargo cults, security theater which you can get anywhere
- Disable Console Access
- Disable Schema Introspection
- Disable Query Suggestions (unnecessary in Hasura)
- Impose API Limits
- Whitelist Operations

*** GraphQL Security Heterodoxy

AKA: possibly controversial opinions which you will get from me
- Don't confuse public vs private:
- If you don't /need/ to provide a public API, then don't.
- If you're not providing a public API, then don't act like you are.
- Don't disable console access
- If you applied the security principles carefully, deliberately, thoughtfully, then the console can't do anything unauthorized anyway.
- Don't disable schema introspection and query suggestions.
- The public will need to know how to use your public API (which you almost certainly shouldn't have anyway)
- The public shouldn't have access to your private API (you did secure your API, add authentication, disable unauthorized access, build a rich data model, and apply fine-grained authorization, didn't you?)
- The information will get out anyway.
- Don't use GraphQL security
- Or at least, don't rely on it.
- Work diligently from the bottom-up, applying the principles carefully, deliberately, thoughtfully, and you (almost) won't need it.
- Remember "managing risk", "cargo cults", and "security theater".
Life is about trade-offs.
- Don't use GraphQL
- For private APIs, that is.
- Use Allow Lists.
- And if you're using Allow Lists, you might as well use REST endpoints.
- GraphQL is for /people/ (i.e. developers), not for machines.

* Closing Remarks

*** References

*** How and where to get help

white_check_mark
100
raised_hands

#  LocalWords:  toc controlsLayout controlsTutorial ATTR hasuraprod
