schema  { query: query_root mutation: mutation_root subscription: subscription_root }

scalar timestamptz

scalar uuid

type __Directive { args: __InputValue
  description: String!
  isRepeatable: String!
  locations: String!
  name: String!
}

type __EnumValue { deprecationReason: String!
  description: String!
  isDeprecated: String!
  name: String!
}

type __Field { args: __InputValue
  deprecationReason: String!
  description: String!
  isDeprecated: String!
  name: String!
  type: __Type
}

type __InputValue { defaultValue: String!
  description: String!
  name: String!
  type: __Type
}

type __Schema { description: String!
  directives: __Directive
  mutationType: __Type
  queryType: __Type
  subscriptionType: __Type
  types: __Type
}

type __Type { description: String!
  enumValues(includeDeprecated: Boolean = false): __EnumValue
  fields(includeDeprecated: Boolean = false): __Field
  inputFields: __InputValue
  interfaces: __Type
  kind: __TypeKind!
  name: String!
  ofType: __Type
  possibleTypes: __Type
}

type query_root { "execute function \"product_search\" and query aggregates on result of table type \"product\"" 
product_search_aggregate("input parameters for function \"product_search_aggregate\"" 
args: product_search_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): product_aggregate!
  "execute function \"product_search\" which returns \"product\"" 
product_search("input parameters for function \"product_search\"" 
args: product_search_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): [product!]!
  "execute function \"product_search_slow\" and query aggregates on result of table type \"product\"" 
product_search_slow_aggregate("input parameters for function \"product_search_slow_aggregate\"" 
args: product_search_slow_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): product_aggregate!
  "execute function \"product_search_slow\" which returns \"product\"" 
product_search_slow("input parameters for function \"product_search_slow\"" 
args: product_search_slow_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): [product!]!
  "fetch aggregated fields from the table: \"product\"" 
product_aggregate("filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): product_aggregate!
  "fetch data from the table: \"product\"" 
product("filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): [product!]!
  "fetch data from the table: \"product\" using primary key columns" 
product_by_pk(id: uuid!): product
}

type subscription_root { "execute function \"product_search\" and query aggregates on result of table type \"product\"" 
product_search_aggregate("input parameters for function \"product_search_aggregate\"" 
args: product_search_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): product_aggregate!
  "execute function \"product_search\" which returns \"product\"" 
product_search("input parameters for function \"product_search\"" 
args: product_search_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): [product!]!
  "execute function \"product_search_slow\" and query aggregates on result of table type \"product\"" 
product_search_slow_aggregate("input parameters for function \"product_search_slow_aggregate\"" 
args: product_search_slow_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): product_aggregate!
  "execute function \"product_search_slow\" which returns \"product\"" 
product_search_slow("input parameters for function \"product_search_slow\"" 
args: product_search_slow_args!, "filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): [product!]!
  "fetch aggregated fields from the table: \"product\"" 
product_aggregate("filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): product_aggregate!
  "fetch data from the table in a streaming manner: \"product\"" 
product_stream("filter the rows returned" 
where: product_bool_exp, "cursor to stream the results returned by the query" 
cursor: [product_stream_cursor_input]!, "maximum number of rows returned in a single batch" 
batch_size: Int!): [product!]!
  "fetch data from the table: \"product\"" 
product("filter the rows returned" 
where: product_bool_exp, "sort the rows by one or more columns" 
order_by: [product_order_by!], "limit the number of rows returned" 
limit: Int, "skip the first n rows. Use only with order_by" 
offset: Int, "distinct select on columns" 
distinct_on: [product_select_column!]): [product!]!
  "fetch data from the table: \"product\" using primary key columns" 
product_by_pk(id: uuid!): product
}

"aggregate avg on columns" 
type product_avg_fields { price: Float
}

"aggregate fields of \"product\"" 
type product_aggregate_fields { avg: product_avg_fields
  count(distinct: Boolean, columns: [product_select_column!]): Int!
  max: product_max_fields
  min: product_min_fields
  stddev: product_stddev_fields
  stddev_pop: product_stddev_pop_fields
  stddev_samp: product_stddev_samp_fields
  sum: product_sum_fields
  var_pop: product_var_pop_fields
  var_samp: product_var_samp_fields
  variance: product_variance_fields
}

"aggregate max on columns" 
type product_max_fields { created_at: timestamptz
  id: uuid
  name: String
  price: Int
  updated_at: timestamptz
}

"aggregate min on columns" 
type product_min_fields { created_at: timestamptz
  id: uuid
  name: String
  price: Int
  updated_at: timestamptz
}

"aggregate stddev on columns" 
type product_stddev_fields { price: Float
}

"aggregate stddev_pop on columns" 
type product_stddev_pop_fields { price: Float
}

"aggregate stddev_samp on columns" 
type product_stddev_samp_fields { price: Float
}

"aggregate sum on columns" 
type product_sum_fields { price: Int
}

"aggregate var_pop on columns" 
type product_var_pop_fields { price: Float
}

"aggregate var_samp on columns" 
type product_var_samp_fields { price: Float
}

"aggregate variance on columns" 
type product_variance_fields { price: Float
}

"aggregated selection of \"product\"" 
type product_aggregate { aggregate: product_aggregate_fields
  nodes: [product!]!
}

"columns and relationships of \"product\"" 
type product@key(fields: "id") { created_at: timestamptz!
  id: uuid!
  name: String!
  price: Int!
  updated_at: timestamptz!
}

"mutation root" 
type mutation_root { "delete data from the table: \"product\"" 
delete_product("filter the rows which have to be deleted" 
where: product_bool_exp!): product_mutation_response
  "delete single row from the table: \"product\"" 
delete_product_by_pk(id: uuid!): product
  "insert a single row into the table: \"product\"" 
insert_product_one("upsert condition" 
on_conflict: product_on_conflict, "the row to be inserted" 
object: product_insert_input!): product
  "insert data into the table: \"product\"" 
insert_product("upsert condition" 
on_conflict: product_on_conflict, "the rows to be inserted" 
objects: [product_insert_input!]!): product_mutation_response
  "update data of the table: \"product\"" 
update_product("sets the columns of the filtered rows to the given values" 
_set: product_set_input, "increments the numeric columns with given value of the filtered values" 
_inc: product_inc_input, "filter the rows which have to be updated" 
where: product_bool_exp!): product_mutation_response
  "update multiples rows of table: \"product\"" 
update_product_many("updates to execute, in order" 
updates: [product_updates!]!): [product_mutation_response]
  "update single row of the table: \"product\"" 
update_product_by_pk("sets the columns of the filtered rows to the given values" 
_set: product_set_input, "increments the numeric columns with given value of the filtered values" 
_inc: product_inc_input, pk_columns: product_pk_columns_input!): product
}

"response of any mutation on the table \"product\"" 
type product_mutation_response { "data from the rows affected by the mutation" 
returning: [product!]!
  "number of rows affected by the mutation" 
affected_rows: Int!
}

enum __TypeKind {ENUM 
  INPUT_OBJECT 
  INTERFACE 
  LIST 
  NON_NULL 
  OBJECT 
  SCALAR 
  UNION 
}

"column ordering options" 
enum order_by {"in ascending order, nulls first" 
asc_nulls_first 
  "in ascending order, nulls last" 
asc 
  "in ascending order, nulls last" 
asc_nulls_last 
  "in descending order, nulls first" 
desc 
  "in descending order, nulls first" 
desc_nulls_first 
  "in descending order, nulls last" 
desc_nulls_last 
}

"ordering argument of a cursor" 
enum cursor_ordering {"ascending ordering of the cursor" 
ASC 
  "descending ordering of the cursor" 
DESC 
}

"select columns of table \"product\"" 
enum product_select_column {"column name" 
created_at 
  "column name" 
id 
  "column name" 
name 
  "column name" 
price 
  "column name" 
updated_at 
}

"unique or primary key constraints on table \"product\"" 
enum product_constraint {"unique or primary key constraint on columns \"id\"" 
product_pkey 
}

"update columns of table \"product\"" 
enum product_update_column {"column name" 
created_at 
  "column name" 
id 
  "column name" 
name 
  "column name" 
price 
  "column name" 
updated_at 
}

input product_search_args {search: String
}

input product_search_slow_args {search: String
  wait: Float
}

input product_updates {"filter the rows which have to be updated" 
where: product_bool_exp!
  "increments the numeric columns with given value of the filtered values" 
_inc: product_inc_input
  "sets the columns of the filtered rows to the given values" 
_set: product_set_input
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'." 
input Int_comparison_exp {_eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'." 
input String_comparison_exp {_eq: String
  _gt: String
  _gte: String
  _in: [String!]
  _is_null: Boolean
  _lt: String
  _lte: String
  _neq: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive" 
_niregex: String
  "does the column NOT match the given POSIX regular expression, case sensitive" 
_nregex: String
  "does the column NOT match the given SQL regular expression" 
_nsimilar: String
  "does the column NOT match the given case-insensitive pattern" 
_nilike: String
  "does the column NOT match the given pattern" 
_nlike: String
  "does the column match the given POSIX regular expression, case insensitive" 
_iregex: String
  "does the column match the given POSIX regular expression, case sensitive" 
_regex: String
  "does the column match the given SQL regular expression" 
_similar: String
  "does the column match the given case-insensitive pattern" 
_ilike: String
  "does the column match the given pattern" 
_like: String
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'." 
input timestamptz_comparison_exp {_eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'." 
input uuid_comparison_exp {_eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"Boolean expression to filter rows from the table \"product\". All fields are combined with a logical 'AND'." 
input product_bool_exp {_and: [product_bool_exp!]
  _not: product_bool_exp
  _or: [product_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  price: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"Initial value of the column from where the streaming should start" 
input product_stream_cursor_value_input {created_at: timestamptz
  id: uuid
  name: String
  price: Int
  updated_at: timestamptz
}

"Ordering options when selecting data from \"product\"." 
input product_order_by {created_at: order_by
  id: order_by
  name: order_by
  price: order_by
  updated_at: order_by
}

"Streaming cursor of the table \"product\"" 
input product_stream_cursor_input {"Stream column input with initial value" 
initial_value: product_stream_cursor_value_input!
  "cursor ordering" 
ordering: cursor_ordering
}

"input type for incrementing numeric columns in table \"product\"" 
input product_inc_input {price: Int
}

"input type for inserting data into table \"product\"" 
input product_insert_input {created_at: timestamptz
  id: uuid
  name: String
  price: Int
  updated_at: timestamptz
}

"input type for updating data in table \"product\"" 
input product_set_input {created_at: timestamptz
  id: uuid
  name: String
  price: Int
  updated_at: timestamptz
}

"on_conflict condition type for table \"product\"" 
input product_on_conflict {constraint: product_constraint!
  update_columns: [product_update_column!]! = []
  where: product_bool_exp
}

"primary key columns input for table: product" 
input product_pk_columns_input {id: uuid!
}
